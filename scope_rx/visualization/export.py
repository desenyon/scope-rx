"""
Export utilities for explanations.
"""

from typing import Optional, List, Dict, Any, Union

import numpy as np
import cv2
from pathlib import Path


def export_visualization(
    attribution: np.ndarray,
    path: Union[str, Path],
    format: str = "auto",
    colormap: str = "jet",
    image: Optional[np.ndarray] = None
):
    """Export visualization to file.
    
    Args:
        attribution: Attribution map.
        path: Output file path.
        format: Output format ('png', 'jpg', 'npy', 'npz', 'auto').
        colormap: Colormap for image formats.
        image: Optional original image for overlay.
    """
    filepath = Path(path)
    
    if format == "auto":
        format = filepath.suffix.lower().strip('.')
    
    if format in ['png', 'jpg', 'jpeg']:
        # Normalize
        attr_min, attr_max = attribution.min(), attribution.max()
        if attr_max - attr_min > 1e-8:
            normalized = (attribution - attr_min) / (attr_max - attr_min)
        else:
            normalized = np.zeros_like(attribution)
        
        # Apply colormap
        colormap_cv2 = getattr(cv2, f"COLORMAP_{colormap.upper()}", cv2.COLORMAP_JET)
        heatmap = cv2.applyColorMap(np.uint8(255 * normalized).astype(np.uint8), colormap_cv2)  # type: ignore[call-overload]
        
        if image is not None:
            # Create overlay
            if image.ndim == 2:
                image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
            elif image.shape[2] == 3:
                image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
            
            if image.dtype != np.uint8:
                if image.max() <= 1.0:
                    image = (image * 255).astype(np.uint8)
                else:
                    image = image.astype(np.uint8)
            
            if heatmap.shape[:2] != image.shape[:2]:
                heatmap = cv2.resize(heatmap, (image.shape[1], image.shape[0]))
            
            output = cv2.addWeighted(image, 0.5, heatmap, 0.5, 0)
        else:
            output = heatmap
        
        cv2.imwrite(str(filepath), output)
        
    elif format == 'npy':
        np.save(str(filepath), attribution)
        
    elif format == 'npz':
        np.savez(str(filepath), attribution=attribution)
        
    else:
        raise ValueError(f"Unsupported format: {format}")


def create_html_report(
    results: List[Dict[str, Any]],
    output_path: str,
    title: str = "ScopeRX Explanation Report"
):
    """Create an HTML report of explanations.
    
    Args:
        results: List of result dictionaries with 'method', 'attribution', 
                 and optionally 'image'.
        output_path: Output HTML file path.
        title: Report title.
    """
    import base64
    from io import BytesIO
    
    html_parts = [
        f"""<!DOCTYPE html>
<html>
<head>
    <title>{title}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        h1 {{ color: #333; }}
        .result {{ margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }}
        .result h2 {{ margin-top: 0; color: #666; }}
        .images {{ display: flex; gap: 20px; flex-wrap: wrap; }}
        .images img {{ max-width: 300px; border-radius: 4px; }}
        .metadata {{ background: #f5f5f5; padding: 10px; margin-top: 10px; border-radius: 4px; }}
    </style>
</head>
<body>
    <h1>{title}</h1>
    <p>Generated by ScopeRX v1.0.0</p>
"""
    ]
    
    for result in results:
        method = result.get('method', 'Unknown')
        attribution = result.get('attribution')
        metadata = result.get('metadata', {})
        
        html_parts.append(f"""
    <div class="result">
        <h2>{method}</h2>
        <div class="images">
""")
        
        if attribution is not None:
            # Convert attribution to base64 image
            attr_min, attr_max = attribution.min(), attribution.max()
            if attr_max - attr_min > 1e-8:
                normalized = (attribution - attr_min) / (attr_max - attr_min)
            else:
                normalized = np.zeros_like(attribution)
            
            heatmap = cv2.applyColorMap(np.uint8(255 * normalized).astype(np.uint8), cv2.COLORMAP_JET)  # type: ignore[call-overload]
            heatmap = cv2.cvtColor(heatmap, cv2.COLOR_BGR2RGB)
            
            # Encode to base64
            from PIL import Image
            img = Image.fromarray(heatmap)
            buffer = BytesIO()
            img.save(buffer, format='PNG')
            img_str = base64.b64encode(buffer.getvalue()).decode()
            
            html_parts.append(f'            <img src="data:image/png;base64,{img_str}" alt="{method}">\n')
        
        html_parts.append("        </div>\n")
        
        if metadata:
            html_parts.append('        <div class="metadata">\n')
            for key, value in metadata.items():
                if not key.startswith('_') and not isinstance(value, np.ndarray):
                    html_parts.append(f"            <p><strong>{key}:</strong> {value}</p>\n")
            html_parts.append("        </div>\n")
        
        html_parts.append("    </div>\n")
    
    html_parts.append("""
</body>
</html>
""")
    
    with open(output_path, 'w') as f:
        f.write(''.join(html_parts))
